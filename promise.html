<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>promise</title>
</head>
<body>
<div class="slider"></div>
<script src="js/slider.js"></script>
<script>
  let slider = new SliderTools();
  slider.on('complete',() => {
    // alert('验证完成');
  });
  /*const promise1 = new Promise((resolve, reject) => {
    console.log('promise1')
  });
  console.log('1', promise1);*/

 /* const promise1 = new Promise((resolve, reject) => {
    setTimeout(() => {
      console.log('hong2');
      resolve('success')
    }, 3000)
  });
  const promise2 = promise1.then(() => {
    throw new Error('error!!!')
  });
  console.log('promise1', promise1);
  console.log('promise2', promise2);
  setTimeout(() => {
    console.log('hong3');
    console.log('promise1', promise1);
    console.log('promise2', promise2)
  }, 2000);*/
  /**
   * promise1 pending
   * promise2 pending
   * error
   * promise1 resolve
   * promise2 pending
   */

  /*const promise = new Promise((resolve, reject) => {
    reject("error");
    // resolve('success');
  });
  promise.catch(error => {
    console.log('error', error);
    // return Promise.reject('error1')
  }).then(res => {
    console.log(res);
    return 1;
  }).then(res => {
    console.log("then1: ", res);
    return 2
  }).then(res => {
    console.log("then2: ", res);
  });*/
  /**
   *  error error
   *  undefined
   *  如果promise reject 则只会走catch回调，catch后的then回调也会调用，因为catch会返回一个新的promise
   *  同理 resolve 则只会走 then 回调
   */

  Promise.resolve().then(() => {
    // return  new Error('error!!!');
    // throw new Error('error!!!');
    return Promise.reject(new Error('error!!!'))
  }).then(res => {
    console.log("then: ", res)
  }).catch(err => {
    console.log("catch: ", err)
  });
  /**
   * then, error~
   * return new Error('error!!!') 会包装成 return Promise.resolve(new Error('error!!!'))
   * 若想抛出错误可以
   * throw new Error('error!!!') 或者
   * return Promise.reject(new Error('error!!!'))
   */
</script>
</body>
</html>
